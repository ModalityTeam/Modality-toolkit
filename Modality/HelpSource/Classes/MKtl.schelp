CLASS:: MKtl
summary:: A class for creating and accessing external controllers
categories:: Libraries>Modality, External Control
related:: Overviews/Modality, Classes/MKtlDesc, Classes/MKtlDevice, Classes/MKtlElementGroup, Classes/MKtlElement

DESCRIPTION::

NOTE::
For a guided tour, start reading at link::Overviews/Modality::.
::

MKtl provides an easy to use interface for devices you can connect to your computer through MIDI, HID, OSC, Serial and eventually other protocols. Beyond that, you will be able to use it for GUI based controllers (yet to be implemented).

MKtl searches for controllers connected to your machine, and gives you a list of available devices. Or, if you already know which controller you want to use, it will look through this list and returns the controller with that name. If it cannot find it, it will replace it with a graphical representation of the controller to simulate it.

For most devices, this requires that someone has made a description file for the device; if there is none, it is easy to make one following the instructions here:
link::Tutorials/How_to_create_a_description_file::

MKtls can also be nested by composing several MKtls; for instance, the iControl ... creates both MIDI and HID devices for communication. For an example and background, see link::Tutorials/Composing_MKtls::


CLASSMETHODS::
PRIVATE:: initClass, prAddDefaultSpecs

METHOD:: all
all available MKtl controllers.
code::
MKtl.all;
::


METHOD:: find
Find all currently connected controllers.
This method calls the find method on all of MKtlDevice's subclasses, and will post a list of available MKtl devices.
code::
MKtl.find;
::



METHOD:: new
Accesses an existing instance of MKtl with the given name, or creates a new instance with that name. As with e.g. JITLib proxies like Ndef, Tdef, Pdef, or OSCdef, MIDIdef etc.

code::
// name and name of description file
k = MKtl('mynano2', "korg-nanokontrol2");

// description file name can also contain wildcards:
l = MKtl('op1', "*op-1");

// if you have several devices of the same kind connected,
// say two nanoKontrol2s, you can get to each of them by multiIndex:
m = MKtl('nk2A', "korg-nanokontrol2", multiIndex: 0);
n = MKtl('nk2B', "korg-nanokontrol2", multiIndex: 1);

// Note that this is the index of the list of multiples only,
// and in the order they show up in the system,
// as is posted from MKtl.find. If you connect your
// devices to the same plugs, they will get the same multiIndex again.
::

argument:: name
The name of the controller as you want to refer to it.

argument:: lookupNameOrDesc
The device description that you want to use. This can be the lookupName of a device that was found MKtl.find, the file name of a description file (without extension), an MKtlDesc object, or a dictionary from which a valid device description can be created.

argument:: lookForNew
Boolean flag whether or not to look for newly attached devices or newly added device descriptions. Default is false. It will always look for devices and device descriptions the first time you open an MKtl.

argument:: multiIndex
if several devices of the identical make are used, multiIndex is the index within the array of identical devices. The order depends on USB plug order, but will be reproduceable if the same plugs are used.


SUBSECTION:: Using specs in MKtl

METHOD:: globalSpecs
A class dictionary of all preset ControlSpecs used by various controller elements.

METHOD:: addSpec, getSpec
add and access by name a ControlSpec in MKtl's dictionary of specs

argument:: key
the name by which to store the spec

argument:: spec
The ControlSpec or a symbol or array that can be converted to a spec.
code::
MKtl.globalSpecs;
MKtl.addSpec(\bipolar, [-1, 1]);
MKtl.getSpec(\bipolar);
::


SUBSECTION:: Using description files, interfacing to MKtlDesc

METHOD:: postLoadableDescs
post the filenames of all loadable device descriptions.
For more details on using description files, see link::Classes/MKtlDesc::

METHOD:: postLoadedDescs
post all currently loaded device descriptions.

METHOD:: descFolders
the folder(s) where MKtlDesc finds description files.

METHOD:: openDescFolder
open folder(s) at index containing description files.

METHOD:: loadDescsMatching
load device description file(s) matching with name from indicated folder(s).

Method:: descIsFaulty
test whether the given desc is faulty.

code::
MKtl.postLoadableDescs;
MKtl.postLoadedDescs;
MKtl.descFolders;
MKtl.openDescFolder(0);
MKtl.loadDescsMatching("*run-n-drive*");
::

METHOD:: postPossible
post all possible (i.e. currently connected or known) devices for the protocol(s) given.
MKtl.postPossible;

Method:: makeLookupName
make a lookupName for a device based on (typically) its protocol, id number and productName.
code::
MKtl.makeLookupName(\hid, 0, "Run'N'Drive - Wireless");
MKtl.makeLookupName(\midiSrc, 0, "nanoKEY");
// osc - is ip addr and port good here?
MKtl.makeLookupName(\osc, "127.0.0.1_57110", "sclang");
::

INSTANCEMETHODS::

METHOD:: name
get and set the name of the MKtl.
This also changes the name under which the MKtl is stored in Mktl.all.
code::
MKtl(\test, "korg-nanokontrol2");
MKtl(\test).name_(\mynano2);
MKtl.all; // \test is gone now, use \mynano2 instead
::

argument:: inname
a Symbol.

METHOD:: gui
Open a gui representation for the MKtl
code::
MKtl(\mynano2).gui;
// or newer and nicer:
MKtlGUI(mktl: MKtl(\mynano2));

::


METHOD:: specs, addLocalSpec, addSpec, getSpec
a local dict for special specs to use with this MKtl's elements or groups.
code::
MKtl(\mynano2).specs;
MKtl(\mynano2).addSpec(\angle, [-pi, pi]);
MKtl(\mynano2).getSpec(\angle);
::

METHOD:: desc
the MKtlDesc object that holds the device information from the description file.
It is used to build the elements and groups of this MKtl.
code::
a = MKtl(\mynano2).desc;
a.fullDesc;		// a dict built from the description file
a.fullDesc.keys;	// the keys of the items in it
a.protocol;			// e.g. the protocol used
a.elementsDesc; 	// the dict of the elements described
a.postElements; 	// post element names and keys/indices in hierarchical order
::
For more, see MKtlDesc


METHOD:: openDevice
Open the hardware device for this MKtl if it was not opened already. It will look automatically for an appropriate device.

argument:: lookAgain
Whether or not to look for newly attached hardware devices.

argument:: multiIndex
Needed when using multiple identical devices to identify which one to create.

code::
// while the run'n'drive is not yet attached,
// this creates a virtual device
m = MKtl( 'funky', "*run-n-drive" );
m.clear;
m.trace(true);
HIDFunc.trace(true);
MKtl.all.removeAt(\funky);

// now I found my run'n'drive and plugged it in:
m.openDevice; // finds it automatically

::

METHOD:: closeDevice
Closes the hardware device if it was open.

METHOD:: mktlDevice
The instance of MKtlDevice that this MKtl uses.

METHOD:: free
Frees the MKtl again and forgets about its existence.
If there was an mktlDevice, closes it.

METHOD:: reset
Reset all actions of the elements in this MKtl to nil.
(should this include the group actions?)

METHOD:: trace
set flag whether incoming data are posted or not.

METHOD:: traceRunning
Whether or not we are printing incoming data currently.


METHOD::rebuild
If new description given is valid, this will rebuild the elements from the new description.
warning:: This will remove any actions you have attached, so only use this method when you are really sure that you want to replace the device description.::

METHOD::enable, disable
enable and disable this MKtl, so one can make multiple MKtls (with different setups of elements) for the same physical device.

METHOD::sync
send all current MKtl values to the physical device, e.g. to move all motorfaders to a freshly recalled preset.


SUBSECTION:: Elements of the MKtl

METHOD:: elements
all control elements (MKtlElement) on the device you may want to listen or talk to. this returns an link::Classes/MKtlElementGroup:: containing a hierarchical tree of link::Classes/MKtlElement::s, organised via link::Classes/MKtlElementGroup::.
code::
MKtl(\funky).elements;
::

METHOD:: elementNames
An alphabetical list of all elementNames in the MKtl.
m = MKtl(\manta, "*manta*");
m.elementNames;

METHOD:: postElements
A pretty printed hierarchical list of the names of the elements
code::
m = MKtl(\manta, "*manta*");
m.postElements;
::

METHOD:: elementsDict
all elements in one flat event so they can be accessed very fast.
code::
MKtl(\funky).elementsDict;
::

METHOD:: inputElements, outputElements
code::
// collect all elements that have inputs:
m.inputElements
//  all elements that have outputs:
m.outputElements
::

METHOD:: elementsOfType, elementsNotOfType
return all elements that are of the type given, or not
code::
MKtl(\mynano2).elementsOfType(\slider);
k.elementsNotOfType(\slider);
::

METHOD:: elementsLabeled
return all elements which have been given a label
code::
o = MKtl(\opi1, "teenage*");
o.elementsLabeled(\white);
::


METHOD:: elementAt
Access an element in the elements hierarchy by passing in the indexes to arrays/dictionaries as arguments of elementAt:

code::
MKtl(\mynano2).elements
MKtl(\mynano2).elementAt(\sl,0);
//the same as
MKtl(\mynano2).elements[\sl][0];
::

METHOD:: at
Access an element in the elements hierarchy by passing in one index.
code:: MKtl(\funky).at(0); ::

argument:: index
Index to get from the elements.

METHOD:: valueAt
Access an element's value by the element key

code::
m = MKtl( 'funky', "*run-n-drive" );
m.valueAt( \compass );
m.valueAt( \bt_2 );

::

METHOD:: deviceValueAt
Access an element's deviceValue (in the deviceSpec range) by the element key

code::
m = MKtl( 'funky', "*run-n-drive" );
m.deviceValueAt( \compass );
m.deviceValueAt( \bt_2 );
m.deviceValueAt( \joy_l_x );
::


METHOD:: setValueAt, setDeviceValueAt
Set an element's value or deviceValue by element key

METHOD:: send
Send the value of the element to the hardware device; called if you set the value of an MKtlElement that is an output.

SUBSECTION:: Exploration of a device

See link::Tutorials/How_to_create_a_description_file:: for a full discussion on this.

METHOD:: explore

When a device doesn't have a description file yet, explore can be used to help in creating one.

METHOD:: exploring
Returns a Boolean whether or not a device is currently being explored.

METHOD:: createDescriptionFile
When a device doesn't have a description file yet, this method can be used to create a description file.

METHOD:: specialMessages
a dict of special messages for this device, typically to change setup on a MIDI device by sending it a sysex message.

METHOD:: sendSpecialMessages
send specMessage with name to the device


Subsection:: Collectives and Composite MKtl

... create collectives in new mktl - to be written.
METHOD:: collectivesDict, collectiveDescriptionFor

methods for finding info on available devices in MKtlLookup.
METHOD:: lookupInfo, lookupName, updateLookupInfo

various tests
METHOD:: checkAllCtls, checkIdentical, hasDevice

private:: wrapCollElemsInGroups, specialMessageNames, sendSpecialMessage, prMatchedElements
PRIVATE:: storeArgs, printOn, init, makeElements, makeCollectives, finishInit

